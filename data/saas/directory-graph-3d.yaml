# Directory Graph 3D
# ディレクトリ構造を3Dネットワークで可視化

- id: directory-graph-3d
  category: 9
  category_name: 3Dエディター
  title: Directory Graph 3D
  content: ""
  custom_html: |
    <script>
      // THREEを先に読み込む（未ロード時のみ）
      if (!window.THREE) {
        const threeScript = document.createElement('script');
        threeScript.src = '//cdn.jsdelivr.net/npm/three@0.158/build/three.min.js';
        document.head.appendChild(threeScript);
      }
      // 3D Force Graphを一度だけ読み込む
      if (!window.ForceGraph3DLoaded) {
        const script = document.createElement('script');
        script.src = '//cdn.jsdelivr.net/npm/3d-force-graph';
        script.onload = () => {
          window.ForceGraph3DLoaded = true;
          console.log('3D Force Graph loaded');
        };
        document.head.appendChild(script);
      }
    </script>
    
    <style>
      body { margin: 0; }
      .directory-graph-container {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 20px;
      }
      .directory-graph-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: var(--text);
        margin-bottom: 16px;
        text-align: center;
      }
      .directory-graph-main {
        display: grid;
        grid-template-columns: minmax(0, 1fr) 320px;
        gap: 20px;
        align-items: start;
      }
      .directory-graph-canvas-container {
        flex: 1 1 70%;
        height: 600px;
        min-height: 600px;
        background: #000003;
        border: 1px solid var(--border);
        border-radius: 8px;
        position: relative;
        min-width: 0;
        overflow: hidden;
      }
      #directory-graph-3d-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
      .directory-graph-info {
        flex: 0 0 28%;
        color: var(--text);
        font-size: 0.9rem;
        padding: 16px;
        background: var(--sidebar-bg);
        border: 1px solid var(--border);
        border-radius: 8px;
      }
      .directory-graph-info h3 {
        color: var(--link);
        margin: 0 0 12px 0;
        font-size: 1.05rem;
      }
      .directory-graph-info ul {
        margin: 0 0 8px 18px;
      }
      .directory-graph-info li {
        margin-bottom: 6px;
        line-height: 1.5;
      }
      .view-toggle {
        margin-top: 12px;
        display: flex;
        gap: 8px;
      }
      .toggle-btn {
        padding: 6px 10px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        cursor: pointer;
      }
      .toggle-btn.active {
        background: var(--link);
        color: #fff;
      }
      .directory-stats {
        margin-top: 16px;
        padding-top: 16px;
        border-top: 1px solid var(--border);
      }
      .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }
      .stat-label {
        color: var(--text-muted);
      }
      .stat-value {
        font-weight: 600;
        color: var(--link);
      }
      @media (max-width: 900px) {
        .directory-graph-main {
          grid-template-columns: 1fr;
        }
        .directory-graph-canvas-container {
          height: 420px;
        }
        .directory-graph-info {
          width: 100%;
        }
      }
      .directory-graph-description {
        color: var(--text);
        line-height: 1.6;
        margin-bottom: 16px;
      }
      .loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #ffffff;
        font-size: 1.2rem;
      }
      /* ノードの凡例 */
      .node-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 12px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }
      .legend-label {
        font-size: 0.85rem;
        color: var(--text-muted);
      }
    </style>
    
    <div class="directory-graph-container">
      <h2 class="directory-graph-title">Directory Graph 3D</h2>
      
      <div class="directory-graph-description">
        SCAN_PATH配下のディレクトリ構造を3D空間で可視化。フォルダとファイルの関係性を
        インタラクティブに探索できます。
      </div>
      
      <div class="directory-graph-main">
        <div class="directory-graph-canvas-container">
          <div id="directory-graph-3d-canvas">
            <div class="loading-message">ディレクトリ構造を読み込み中...</div>
          </div>
        </div>
        
        <div class="directory-graph-info">
          <h3>操作方法</h3>
          <ul>
            <li><strong>マウス</strong>
              <ul>
                <li>ドラッグ: 視点変更</li>
                <li>ホイール: ズーム</li>
                <li>ダブルクリック: リセット</li>
              </ul>
            </li>
            <li><strong>ノード</strong>
              <ul>
                <li>クリック: 詳細表示</li>
                <li>ドラッグ: 移動</li>
                <li>ホバー: 名前表示</li>
              </ul>
            </li>
            <li><strong>キーボード</strong>
              <ul>
                <li>R: 再配置</li>
                <li>C: カメラリセット</li>
                <li>F: 全体フィット</li>
              </ul>
            </li>
          </ul>
          
          <div class="view-toggle">
            <button class="toggle-btn active" id="toggle-color-mode">色で表示</button>
            <button class="toggle-btn" id="toggle-media-mode">メディアで表示</button>
          </div>

          <div class="directory-stats">
            <h3>統計情報</h3>
            <div id="directory-stats-content">
              <div class="stat-item">
                <span class="stat-label">フォルダ数:</span>
                <span class="stat-value" id="folder-count">-</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">ファイル数:</span>
                <span class="stat-value" id="file-count">-</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">画像:</span>
                <span class="stat-value" id="image-count">-</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">動画:</span>
                <span class="stat-value" id="video-count">-</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">音声:</span>
                <span class="stat-value" id="audio-count">-</span>
              </div>
              <div class="stat-item">
                <span class="stat-label">HTML:</span>
                <span class="stat-value" id="html-count">-</span>
              </div>
            </div>
          </div>
          
          <div class="node-legend">
            <div class="legend-item">
              <div class="legend-color" style="background: #ff6b6b;"></div>
              <span class="legend-label">ルート</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #4ecdc4;"></div>
              <span class="legend-label">フォルダ</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #ffa502;"></div>
              <span class="legend-label">画像</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #6c5ce7;"></div>
              <span class="legend-label">動画</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #feca57;"></div>
              <span class="legend-label">音声</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #dfe6e9;"></div>
              <span class="legend-label">HTML</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <script type="module">
      // 3D Force Graphが読み込まれるまで待機
      function initDirectoryGraph() {
        console.log('initDirectoryGraph called, ForceGraph3D:', typeof ForceGraph3D);
        if (typeof ForceGraph3D === 'undefined') {
          setTimeout(initDirectoryGraph, 100);
          return;
        }
        
        // 対象セクションが可視になるのを待ってから初期化
        const section = document.getElementById('directory-graph-3d');
        const canvasEl = document.getElementById('directory-graph-3d-canvas');
        const waitUntilVisible = () => {
          if (!section || !canvasEl) {
            setTimeout(waitUntilVisible, 200);
            return;
          }
          const visible = window.getComputedStyle(section).display !== 'none';
          const rect = canvasEl.getBoundingClientRect();
          if (visible && rect.width > 0 && rect.height > 0) {
            fetchDirectoryStructure().then(data => {
              if (data) createDirectoryGraph(data);
            });
          } else {
            setTimeout(waitUntilVisible, 200);
          }
        };
        waitUntilVisible();
      }
      
      // ディレクトリ構造を取得
      async function fetchDirectoryStructure() {
        try {
          // localhost:7777のサーバーから取得
          const response = await fetch('http://localhost:7777/api/scan');
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const result = await response.json();
          console.log('API Response:', result);
          return result;
        } catch (error) {
          console.error('Error fetching directory structure:', error);
          document.querySelector('.loading-message').textContent = 
            'エラー: サーバーに接続できません。backend/server.js が起動していることを確認してください。';
          return null;
        }
      }
      
      // ディレクトリ構造をグラフデータに変換
      function convertToGraphData(directoryData) {
        const nodes = [];
        const links = [];
        let nodeId = 0;
        const stats = {
          folders: 0,
          files: 0,
          images: 0,
          videos: 0,
          audio: 0,
          html: 0,
          yaml: 0,
          json: 0,
          code: 0,
          text: 0,
          doc: 0,
          other: 0
        };
        
        // ルートノードを追加
        const rootNode = {
          id: nodeId++,
          name: 'ROOT',
          type: 'root',
          path: directoryData.baseDir,
          group: 1
        };
        nodes.push(rootNode);
        
        // 再帰的にノードとリンクを作成
        function processDirectory(dirData, parentId, depth = 0) {
          // フォルダを処理
          if (dirData.folders) {
            dirData.folders.forEach(folder => {
              const folderId = nodeId++;
              nodes.push({
                id: folderId,
                name: folder.name,
                type: 'folder',
                path: folder.path,
                group: 2,
                depth: depth
              });
              links.push({
                source: parentId,
                target: folderId
              });
              stats.folders++;
              
              // サブフォルダを再帰的に処理
              if (folder.items) {
                processDirectory(folder.items, folderId, depth + 1);
              }
            });
          }
          
          // ファイルを処理
          if (dirData.files) {
            dirData.files.forEach(file => {
              const fileId = nodeId++;
              let group = 10; // デフォルト(その他)
              // サーバー側タイプが不明な場合は拡張子から解決
              const ext = (file.ext || (file.name.split('.').pop() || '')).toLowerCase();
              let resolvedType = file.type;
              if (!resolvedType || resolvedType === 'other') {
                const isImage = ['jpg','jpeg','png','gif','webp','svg'].includes(ext);
                const isVideo = ['mp4','mov','avi','mkv','webm'].includes(ext);
                const isAudio = ['mp3','wav','ogg','flac','m4a'].includes(ext);
                const isHtml  = ['html','htm'].includes(ext);
                const isYaml  = ['yml','yaml'].includes(ext);
                const isJson  = ['json'].includes(ext);
                const isText  = ['txt','md','markdown','log'].includes(ext);
                const isCode  = ['js','ts','tsx','jsx','py','rb','go','rs','java','c','cc','cpp','h','hpp','cs','php','sh','bash','zsh','fish'].includes(ext);
                const isDoc   = ['pdf','doc','docx','ppt','pptx','xls','xlsx','csv','tsv'].includes(ext);
                resolvedType = isImage ? 'image'
                  : isVideo ? 'video'
                  : isAudio ? 'audio'
                  : isHtml  ? 'html'
                  : isYaml  ? 'yaml'
                  : isJson  ? 'json'
                  : isCode  ? 'code'
                  : isText  ? 'text'
                  : isDoc   ? 'doc'
                  : 'other';
              }

              switch(resolvedType) {
                case 'image':
                  group = 3; // 画像
                  stats.images++;
                  break;
                case 'video':
                  group = 4; // 動画
                  stats.videos++;
                  break;
                case 'audio':
                  group = 5; // 音声
                  stats.audio++;
                  break;
                case 'html':
                  group = 6; // HTML
                  stats.html++;
                  break;
                case 'yaml':
                  group = 7; // YAML
                  stats.yaml++;
                  break;
                case 'json':
                  group = 8; // JSON
                  stats.json++;
                  break;
                case 'code':
                  group = 9; // コード
                  stats.code++;
                  break;
                case 'text':
                  group = 11; // テキスト
                  stats.text++;
                  break;
                case 'doc':
                  group = 12; // ドキュメント
                  stats.doc++;
                  break;
                default:
                  stats.other++;
              }
              
              nodes.push({
                id: fileId,
                name: file.name,
                type: resolvedType,
                path: file.path,
                size: file.size,
                group: group,
                depth: depth
              });
              links.push({
                source: parentId,
                target: fileId
              });
              stats.files++;
            });
          }
        }
        
        // ディレクトリ構造を処理
        processDirectory(directoryData.data, rootNode.id);
        
        console.log('Graph data:', { nodes: nodes.length, links: links.length, stats });
        return { nodes, links, stats };
      }
      
      // グラフを作成
      function createDirectoryGraph(directoryData) {
        const container = document.getElementById('directory-graph-3d-canvas');
        console.log('Container found:', container);
        if (!container) {
          console.error('Container not found');
          return;
        }
        
        // コンテナのサイズを確認
        const rect = container.getBoundingClientRect();
        console.log('Container size:', rect.width, 'x', rect.height);
        
        // ローディングメッセージを削除
        container.innerHTML = '';
        
        const graphData = convertToGraphData(directoryData);
        
        // データが空の場合の処理
        if (graphData.nodes.length === 0) {
          container.innerHTML = '<div class="loading-message">データがありません</div>';
          return;
        }
        
        // 統計情報を更新（同一セクション内にスコープ）
        const sectionRoot = container.closest('.doc-section') || document;
        const folderEl = sectionRoot.querySelector('#folder-count');
        const fileEl = sectionRoot.querySelector('#file-count');
        const imageEl = sectionRoot.querySelector('#image-count');
        const videoEl = sectionRoot.querySelector('#video-count');
        const audioEl = sectionRoot.querySelector('#audio-count');
        const htmlEl = sectionRoot.querySelector('#html-count');
        const yamlEl = sectionRoot.querySelector('#yaml-count');
        const jsonEl = sectionRoot.querySelector('#json-count');
        const codeEl = sectionRoot.querySelector('#code-count');
        const textEl = sectionRoot.querySelector('#text-count');
        const docEl = sectionRoot.querySelector('#doc-count');
        const otherEl = sectionRoot.querySelector('#other-count');
        if (folderEl) folderEl.textContent = graphData.stats.folders;
        if (fileEl) fileEl.textContent = graphData.stats.files;
        if (imageEl) imageEl.textContent = graphData.stats.images;
        if (videoEl) videoEl.textContent = graphData.stats.videos;
        if (audioEl) audioEl.textContent = graphData.stats.audio;
        if (htmlEl) htmlEl.textContent = graphData.stats.html;
        if (yamlEl) yamlEl.textContent = graphData.stats.yaml;
        if (jsonEl) jsonEl.textContent = graphData.stats.json;
        if (codeEl) codeEl.textContent = graphData.stats.code;
        if (textEl) textEl.textContent = graphData.stats.text;
        if (docEl) docEl.textContent = graphData.stats.doc;
        if (otherEl) otherEl.textContent = graphData.stats.other;
        
        // カラーパレット
        const colorPalette = {
          1: '#ff4757', // ルート - 強い赤
          2: '#2ed573', // フォルダ - 鮮やかなグリーン
          3: '#ffb84d', // 画像 - 薄いオレンジ
          4: '#6c5ce7', // 動画 - パープル
          5: '#eccc68', // 音声 - 温かいイエロー
          6: '#a4b0be', // HTML - グレー
          7: '#6c5ce7', // YAML - パープル（動画と同系色だが別用途）
          8: '#00d2d3', // JSON - ティール
          9: '#ff6b81', // コード - ピンクレッド
          10:'#57606f', // その他 - ダークグレー
          11:'#70a1ff', // テキスト - ライトブルー
          12:'#2f3542'  // ドキュメント - ダーク
        };
        
        console.log('Creating graph with container:', container);
        const Graph = ForceGraph3D()(container)
          .backgroundColor('#000003')
          .graphData(graphData)
          .nodeLabel(node => `${node.name}\n${node.type === 'folder' ? 'フォルダ' : node.type}`)
          .nodeColor(node => colorPalette[node.group] || '#ffffff')
          .nodeOpacity(0.9)
          .nodeResolution(16)
          .nodeVal(node => {
            // ノードサイズを種類に応じて設定
            if (node.type === 'root') return 30;
            if (node.type === 'folder') return 15;
            if (node.type === 'video') return 10;
            if (node.type === 'image') return 8;
            return 6;
          })
          .linkOpacity(0.75)
          .linkWidth(4)
          .linkColor(() => 'rgba(255,255,255,0.5)')
          .linkDirectionalParticles(2)
          .linkDirectionalParticleWidth(3)
          .linkDirectionalParticleSpeed(0.01)
          .enableNodeDrag(true)
          .enableNavigationControls(true)
          .showNavInfo(false)
          .d3VelocityDecay(0.3)
          .d3AlphaDecay(0.02)
          .dagMode(null);
        // 個別適用（エラー回避）
        try {
          Graph.d3Force('charge').strength(-300);
          Graph.d3Force('link').distance(80);
        } catch (e) {
          console.warn('d3Force setup skipped:', e);
        }
        const finalizedGraph = Graph
          .warmupTicks(100)
          .cooldownTicks(0)
          .onNodeClick(node => {
            console.log('Node clicked:', node);
            
            // ノードの詳細を表示
            alert(`名前: ${node.name}\nタイプ: ${node.type}\nパス: ${node.path}`);
            
            // ノードにフォーカス
            const distance = 40;
            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
            Graph.cameraPosition(
              { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
              node,
              3000
            );
          })
          .onNodeHover(node => {
            container.style.cursor = node ? 'pointer' : null;
            // 画像ノードの場合はプレビューを表示
            const prevId = 'image-preview-tooltip';
            let tooltip = document.getElementById(prevId);
            if (node && node.type === 'image') {
              if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = prevId;
                tooltip.style.position = 'fixed';
                tooltip.style.padding = '6px';
                tooltip.style.background = 'rgba(0,0,0,0.8)';
                tooltip.style.border = '1px solid rgba(255,255,255,0.2)';
                tooltip.style.borderRadius = '6px';
                tooltip.style.zIndex = '9999';
                tooltip.style.pointerEvents = 'none';
                tooltip.innerHTML = '<img style="max-width:200px; max-height:160px; display:block;" />\n<span style="color:#fff; font-size:12px"></span>';
                document.body.appendChild(tooltip);
              }
              const img = tooltip.querySelector('img');
              const cap = tooltip.querySelector('span');
              // 画像はバックエンド(7777)から配信する
              img.src = `http://localhost:7777/${encodeURI(node.path)}`;
              cap.textContent = node.name;
              // マウス位置に追従（複数回バインドを避ける）
              if (!tooltip.dataset.bound) {
                document.addEventListener('mousemove', (e) => {
                  tooltip.style.left = (e.clientX + 12) + 'px';
                  tooltip.style.top = (e.clientY + 12) + 'px';
                });
                tooltip.dataset.bound = '1';
              }
              tooltip.style.display = 'block';
            } else if (tooltip) {
              tooltip.style.display = 'none';
            }
          })
          .onNodeDragEnd(node => {
            node.fx = node.x;
            node.fy = node.y;
            node.fz = node.z;
          });
        
        // 軽量なグロー: ノードサイズを上げて代替的に「光らせる」表現
        // Threeの多重ロード回避のためpostprocessingは使わず視覚的に強調
        
        // ダブルクリックでリセット
        container.addEventListener('dblclick', () => {
          Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
        });
        
        // キーボードショートカット（このグラフがフォーカスされている場合のみ）
        let keyHandler = (event) => {
          // コンテナまたはその子要素がフォーカスされているかチェック
          if (!container.contains(document.activeElement) && document.activeElement !== document.body) {
            return;
          }
          
          if (event.key === 'r' || event.key === 'R') {
            // Rキーで再配置
            Graph.d3ReheatSimulation();
          } else if (event.key === 'c' || event.key === 'C') {
            // Cキーでカメラリセット
            Graph.cameraPosition({ x: 0, y: 0, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
          } else if (event.key === 'f' || event.key === 'F') {
            // Fキーでフィット
            Graph.zoomToFit(1000, 100);
          }
        };
        
        // コンテナをクリックしたときにキーボードイベントを有効化
        container.addEventListener('click', () => {
          container.tabIndex = -1;
          container.focus();
        });
        
        document.addEventListener('keydown', keyHandler);
        
        // 初期カメラ位置を設定（より遠くから全体を見渡せるように）
        Graph.cameraPosition({ x: 0, y: 0, z: 1000 });
        
        // 初期表示時に全体をフィット
        setTimeout(() => {
          console.log('Graph created, checking container:', container.getBoundingClientRect());
          console.log('Graph scene:', Graph.scene());
          console.log('Graph camera:', Graph.camera());
          Graph.zoomToFit(1000, 100);
        }, 500);
        
        // グラフ作成完了ログ
        console.log('Directory graph creation completed');
        
        // 定期的にコンテナの状態をチェック（デバッグ用）
        setTimeout(() => {
          const rect = container.getBoundingClientRect();
          console.log('Container after 2s:', rect.width, 'x', rect.height);
          console.log('Container display:', window.getComputedStyle(container).display);
          console.log('Container visibility:', window.getComputedStyle(container).visibility);
          console.log('Container children:', container.children.length);
          console.log('Canvas found:', container.querySelector('canvas'));
        }, 2000);
        // 表示モード切り替え
        const colorBtn = document.getElementById('toggle-color-mode');
        const mediaBtn = document.getElementById('toggle-media-mode');
        let showMediaTexture = false;
        const applyActive = () => {
          colorBtn.classList.toggle('active', !showMediaTexture);
          mediaBtn.classList.toggle('active', showMediaTexture);
        };
        applyActive();
        
        // 画像/動画ノードにテクスチャ適用
        const loader = new Image();
        const getVideoThumbUrl = (path) => `http://localhost:7777/${encodeURI(path)}`; // ひとまず同URLを使用（将来サムネAPIに）
        
        const textureCache = new Map();
        function setMediaTextures(enabled) {
          showMediaTexture = enabled;
          applyActive();
          Graph.nodeThreeObject(node => {
            if (!enabled) return undefined; // デフォルト描画
            if (node.type !== 'image' && node.type !== 'video') return undefined;
            const key = `${node.type}:${node.path}`;
            if (!textureCache.has(key)) {
              const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ color: 0xffffff }));
              const img = new Image();
              img.crossOrigin = 'anonymous';
              img.onload = () => {
                const tex = new THREE.Texture(img);
                tex.needsUpdate = true;
                sprite.material.map = tex;
                sprite.material.needsUpdate = true;
              };
              img.src = node.type === 'image' ? `http://localhost:7777/${encodeURI(node.path)}` : getVideoThumbUrl(node.path);
              sprite.scale.set(16, 12, 1);
              textureCache.set(key, sprite);
            }
            return textureCache.get(key);
          });
          // 再描画
          Graph.refresh();
        }
        mediaBtn?.addEventListener('click', () => setMediaTextures(true));
        colorBtn?.addEventListener('click', () => setMediaTextures(false));
      }
      
      // 初期化開始（ページ読み込み完了後）
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDirectoryGraph);
      } else {
        // 既に読み込み完了している場合
        setTimeout(initDirectoryGraph, 100);
      }
    </script>
